\documentclass{article}
\usepackage{xspace}
\usepackage[breaklinks=true]{hyperref}
\usepackage{listings}


\title{Git and \LaTeX}
\author{Seamus Bradley\\Charlie Tanksley}
\date{\today}

\begin{document}
\lstset{language=[LaTeX]TeX,breaklines=true,frame=single,frameround=tttt}
  \maketitle
  \tableofcontents

If you are using \LaTeX, you should be using a version control system 
or VCS. In this post I'm going to explain what a VCS is and why you 
should use one. In a later post I'll explain how I use the particular 
version control system I use, \href{http://git-scm.com}{git}. Which 
version control system you use is not terribly important. But I think 
using a VCS is.

\section{What is a VCS?}

If you've ever used the 'Track Changes' feature in Microsoft Word, 
you've used \emph{revision control}. A \emph{version control system} 
is a program that basically tracks the revisions you make to your 
document. The term 'version control' comes from the idea that this 
software tracks versions of your documents. Apparently that is the way 
old VCSs worked; now, 
\href{http://www.joelonsoftware.com/items/2010/03/17.html}{from what I 
  have read}, apparently the VCS you will use tracks sets of changes 
to your document, not revisions. From my perspective, that is a 
distinction without a difference, though under the hood I'm guessing 
it makes a substantial difference.

So a version control system is a way for you, the author of a paper, 
to track the changes you have made to that document. But there is a 
difference between 'Track Changes' and a VCS—with a VCS, you are in 
control: you save \textbf{chunks} of changes, not individual changes 
(though an individual change is the smallest chunk!). What is more, 
you manually append a message to each hunk of changes. These messages, 
and the discrete units of change, are two of the things that make a 
VCS so powerful.

\section{Basic mechanics}

You are writing a paper, and you are doing so in \LaTeX with your 
favorite editor.  Suppose the paper is \verb!paper.tex!, and suppose 
you are at the point where you are revising the paper—you have a draft 
and you need to rework numerous sections. If you are using a VCS 
(which you have already told to watch \verb!paper.tex!) your basic 
workflow will look something like this:

\begin{enumerate}
\item
  Write some. Maybe you delete half of a section and rewrite it.
\item
  \emph{Commit} your changes. That is, you have already told your VCS 
  to keep its eyes on \verb!paper.tex!, now you are telling the VCS 
  about the changes you've made. Your VCS will know exactly what words 
  you changed, what you added, and what you deleted; when you commit 
  your changes you are telling the VCS to (a) save the hunk of changes 
  you just made as one \textbf{unit} and (b) attach a description of 
  those changes that you provide.
\item
  Write more.
\item
  Commit those changes.
\end{enumerate}
Most of your time will be spent like that. You will change section 1, 
then tell your VCS to save those changes along with the comment 
'changed section 1 to narrow the focus', for example.

\section{Slightly more advanced mechanics}

If that was \emph{all} a VCS did it might be valuable; but a VCS can 
do much more.

Suppose you decide that you want to try out some pretty radical 
changes to the paper—maybe you move section 7 to the front, cut out 
sections 2 and 6, and write three new sections at the end. Plus you 
change the definition of some key term (which you repeat throughout).

These major rewrites are common. They are also scary. What if you make 
all those changes and the new version turns out worse than the current 
version? How would you go back to where you started?

If you are using a VCS, that mistake isn't quite so terrible. It isn't 
terrible because all you have to do is look at the history of your 
document, find the old version (this isn't very hard, and you can make 
it even easier if you have a proper workflow), and issue a single 
command to revert your paper to that old version.

(I realize you could do something like this without a VCS—you could 
save a copy of the paper \verb!good_version_from_december_7.tex! or 
whatever. I'll talk more about this below.)

Or suppose that you realize that while the new version isn't better 
than the old version, the new definition you introduced for that term 
(and changed throughout the document) is much better. If you know how 
to use your VCS, you can throw away all the changes you made to the 
document \emph{except} that changed definition. That change you can 
keep. So you end up with the old version plus the new definition 
throughout.

\section{But why use a VCS?}

People who don't use a VCS likely have one of two approaches to paper 
versions. One is the \verb!paper_1.tex!, \verb!paper_2.tex!, etc. 
approach. With this approach, you create a new draft at every 
significant milestone or when you want to try something new. The other 
approach is to have one version of the paper and just plow ahead; you 
commit to changes or to figuring out how to get things back if you 
make a mistake.

(There is a new version of this second approach, which is to put your 
paper in a Dropbox folder. If you do this, then every time you save 
the file you will replace the old version, \textbf{but} Dropbox will 
keep that old revision for some amount of time. So you can use Dropbox 
to go back in time to an older version (Mac OS X's Time Machine does 
the same thing). This is kind of like a Track-Changes-in-chunks 
feature, where the chunks are demarcated by your saving operations. 
But I don't think it is as good as using a VCS. More on this to 
follow.)

These aren't terrible strategies at all. And maybe you don't want to 
(or can't) be bothered with learning yet another new piece of software 
to track your changes, so maybe you want to stick with one of these 
methods. That's fine; you should stick with your current strategy.

But there is a better way: use a VCS. I think there are \textbf{four} 
advantages to using a VCS:

\begin{enumerate}
\item
  It is elegant.
\item
  It allows you to experiment for low cost.
\item
  It gives you control over your version history. And control is a 
  good thing (you use \LaTeX don't you?  Isn't that because it gives 
  you control over your work?).
\item
  It gives you an actual \emph{history} for your document.
\end{enumerate}

\section{A VCS is elegant}

Above I noted that there are two common strategies for keeping up with 
drafts. The first is the save-multiple-drafts method. Everyone knows 
this method is no good. You usually don't have a clue about what has 
changed from draft to draft. There is no way to use the information in 
the old draft unless you just go back to it and throw out anything new 
you've done. This kind of system is like a safety net of sorts. But 
when I was using this system I knew I'd never go back to an old draft. 
So they were more or less pointless.

A VCS keeps one copy of your file. It has its own mechanism for 
keeping track of older versions. So you have one \verb!paper.tex!  
file. If you decide you want to go back to a version from two months 
ago, you issue a command and the contents of \verb!paper.tex! change 
to that old version. The new one is still there—a simple command 
brings you back. So \verb!paper.tex! is now slightly magical: it can 
turn into any document in its history at your command.

When you make a commit (tell the VCS about some changes), you write a 
commit message. You could make these as uninformative as you like (my 
first few months of messages were pretty weak). So if you change the 
definition of 'four-dimensionalism' throughout you could have a commit 
message that reads \verb!made some changes! or \verb!changed the 
definition of four-dimensionalism throughout!. If you go with the 
latter, then when you look at your history you can see exactly what 
you did.

Most VCSs will let you tag a version of a file. So you could say that 
the version of \verb!paper.tex! from 8am on November 2010 is v1.0. 
When you do that, you should have the option to write a detailed 
message about this version. So you could say what you liked about this 
version but what you are thinking about changing.  Then when you look 
at your history you can see how each version differs.

\section{Experimentation}

I abandoned the save-multiple-drafts method because it was pointless 
for me. Never once did I go back to an older version. The problem was 
the opacity of versions: I had no clue what I had changed from one 
version to the next. The previous versions were dead to me. Instead, I 
just plowed ahead with one version, making changes as I saw fit.

The problem with this approach is fear. If you have a decent draft, 
you don't want to ruin it by taking a risk. So that good idea goes 
unexplored. If I strike off in a new direction and change my mind, I 
can't go back. So I don't want to experiment. I'll take a new 
direction, but only if I'm pretty sure about it.

With a VCS, I can stick with the barge-ahead method, but I know I can 
always go back to wherever I need. It seems to me to be the best of 
both worlds. If I want to try a completely new structure, I can do 
that without fear. With a simple command I can switch back and forth 
between versions.

(Thanks do 
\href{http://philosophy.csusb.edu/~dotto/me/Home.html}{Darcy Otto} for 
talking about these ideas with me.)

\section{Control}

Using a VCS is one extra step in the writing process. At regular 
intervals you have to explicitly put a hunk of changes in your 
repository and write a commit message. At first this might seem like a 
nuisance. And for some it might be. But I like it. I like that it 
gives me a chance to plan what I want do to do next, to do just that 
much, and then to explain what I did. It gives my writing more 
purpose. I'm not sitting down to bang out ideas and words—I'm sitting 
down to explain how this conclusion is a problem for so-and-so. That 
direction helps me as a writer.

Dropbox and Word's Track Changes will keep track of versions of your 
paper. But you have very little control over what those versions look 
like. If you save often and reflexively (or automatically), then the 
difference between two Dropbox versions might be a single sentence. 
And there is no way to know what that difference is (well, you could 
save each version separately and use a diff tool to see, but that is a 
lot of work!). With a VCS, you determine how many, and which, changes 
are worth marking as a single hunk of work. Sometimes this is a 
burden. But usually it isn't a very big deal. And the payoff is big: 
the different versions are meaningful, not random. They are in your 
control.

\section{History}

Suppose you wrote a draft of a paper and put it aside for a few weeks 
or months (perhaps because you got busy, perhaps to look at it with 
fresh eyes). How do you get reacquainted with the project when you 
pick it back up? You could just get cracking. Or you could read the 
whole paper. If you are using a VCS, you could view the log of commit 
messages you made. Though it won't always do the trick, this can 
really put you back in touch with the paper. You don't just see what 
you \textbf{have}, you see what you \textbf{had} and why you changed 
it to what you have now. You can see that you were spending lots of 
time on section 7, that you had doubts about a given argument, or 
whatever. (Of course, you have to have good commit messages for this 
to work!)

I use my VCS, git, for this all the time. I'm fond of a program called 
\href{http://jonas.nitro.dk/tig/}{Tig} that lets me view a graphical 
representation of my git repository in a terminal (there are other GUI 
alternatives). So I run \verb!tig --all! in a terminal and can very 
quickly see where I've been working recently.  This is something like 
a high-tech version of reading the last paragraph you wrote yesterday 
before you start writing today. Only this version is quite helpful 
when you are revising.

You could also use this for a longer term view of the project.  
\href{http://www.travisswicegood.com/}{Travis Swicegood} suggested the 
following to me (via Twitter):

\begin{quote}
Use it for review later. It gives insight into the 
creative/intellectual history of the work.

\end{quote}
This seems like a good idea to me, if you are interested in such 
things. If you kept good commit messages, you might find some new 
research ideas by going back through your history.

\section{Conclusion}

I don't think a VCS is for everyone. It does take some work, and that 
extra work might not be justified for you. But I'll just say that I 
don't know anyone who has started using a good VCS (e.g, 
\href{http://mercurial.selenic.com/}{Mercurial} or 
\href{http://git-scm.com/}{git}) and regretted it. Most of us can't 
live without it and can't imagine going back. Just like most of us 
\LaTeX users can't imagine going back to Word.


\section{Making branches work for you}

I recently wrote a
\href{http://www.charlietanksley.net/philtex/using-a-version-control-system/}{post about using a version control system}
when you write LaTeX documents. In this post I want to talk about a
specific feature of the workflow that I've adopted for my
philosophical writing: branching.

As I mentioned in the previous post, I use
\href{http://git-scm.com/}{git} for my version control needs. One
of the distinctive features of git is that \emph{branches} are
cheap—that is, they are easy to create, easy to integrate into a
workflow, and require very little memory. In this post I'm going to
give a basic explanation of how branches work, explain a toy
example using branches, and then explain how I recently used
branches in a paper.

(I \textbf{think} that cheap branches are a \textbf{distinctive}
feature of git. I could be wrong about this, though. For what it is
worth, if you are using
\href{http://mercurial.selenic.com/}{Mercurial}, there is an
\href{http://stevelosh.com/blog/2009/08/a-guide-to-branching-in-mercurial/}{excellent article explaining how to use bookmarks}
in a way similar to my use of branches.)

\subsection{Branches}

When you use git, you put the files you are tracking in a
repository. You make commits to this repository as you like. A
commit has multiple parts. The two of interest to us now are the
commit message and the change set. Suppose you have a five line
long document and you change the second line from x to y. Then when
you \verb!git commit -am 'meaningful commit message'! to commit
your (tracked) document, git makes a record that says line 2 of the
document was changed to y and attaches your message. After you've
done this a number of times, you end up with a long trail of
changes:

\includegraphics{http://www.charlietanksley.net/images/blog/git-branches-development-line.png}

Call this long line the \emph{development line} of the document.
\emph{Branches} allow you to create multiple parallel development
lines for one document that intersect when and where you see fit.

\subsubsection{Creating branches}

You create a branch in git with the \verb!git branch <branchname>!
command. You check out a branch with
\verb!git checkout <branchname>!. (You can create and checkout a
branch with \verb!git checkout -b <branchname>!.) Branching is
cheap in git in three ways. For one thing, they are easy to create
(we just created one). More importantly, they require very little
overhead (that you need to be aware of). Some version control
systems apparently create a copy of the entire directory when you
create a branch. So in effect, if I have a directory
\verb!papers/current-paper! and I want to create a new branch, I
end up with something like this:

\begin{verbatim}
papers/
- current-paper(main_branch)
- current-paper(new_branch)
\end{verbatim}
I guess that should count as a branch, but it seems wasteful and
confusing. Part of the reason you are using a version control
system is to avoid having lots of versions of your paper saved with
various version-numbers in the name. So it seems odd to do this
exact thing when you create a branch.

When you create a branch in git, you don't really create anything
new (strictly I suppse you create a new pointer to follow certain
change sets, or something like that—but my point is that you don't
create any new \emph{files}). Instead, git just keeps track of the
different sets of changes. When you open up \verb!papers/!, you see
one copy of your files. Suppose that file \verb!paper.tex! is 20
paragraphs long in the main (or \emph{master}) branch. Now suppose
you have a branch, \emph{shorter}, that is only 12 paragraphs long.
If you are on the master branch and run
\verb!git checkout shorter!, the copy of \verb!paper.tex! in that
directory will become (magically!) only 12 paragraphs long. If you
\verb!git checkout master!, then \verb!paper.tex! will change back.
There is just one file. You could have one paper in ten different
states, and you could make that single file be in any of those
states with one command.

This model of branching is very neat and tidy, as it ensures you
only have one copy of each file in your directory (unless you
duplicate it yourself, of course). You can, at any point in time,
create a branch off any of your development lines from any point on
said line. So you could create a branch that starts at the tip of a
given line, or you could go back two weeks ago and create a branch
there. Creating branches is cheap and easy.

Sometimes you'll want to create a branch that branches off the main
development line for one or two changes. I usually do this for
submissions to journals. I take the paper at its best state and
\verb!git checkout -b <journal name>! to create a branch for that
journal. Then I do the things I need to do to make it ready for
submission (like making it blind review). Then compile, print, and
submit that version. I can then \verb!git checkout master! and
switch back to my current version, sans any journal specific
changes. This is nice for two reasons. First, at any point I can
quickly and easily retrieve the exact version I submitted to the
journal (a \verb!git branch! will tell me all my branch names, then
I can easily check it out and compile it). Two, I don't have to
make the changes (like making it blind review), get it ready to
submit, and then undo all the changes for my working version. When
I give a paper to a friend I need to have my name on the pages,
etc., I don't want to keep it blind (or completely double-spaced or
whatever the journal wants). It is easy to switch back to my
current version. (Added benefit: if you don't delete the branches,
you have an easy record of where (and when) you submitted the
paper.)

\subsubsection{Merging branches}

Sometimes you want to create a branch that dead ends—like in the
journal example. But other times you'll want to create branches
that you want to use later. In this case, you'll get to see the
other feature of git branches that makes branching so cheap—easy,
fairly accurate merging. (I don't know how git merging compares to
merging in other systems, so maybe this is all just a given;
nevertheless, it bears mentioning here.) Branching can get
complicated, but in most cases it is pretty straightfoward. You
create a your \emph{shorter} branch, do some work on it, and then
when you are ready, you checkout the \emph{master} branch and run
\verb!git merge shorter!. Git will automatically take the changed
lines from the \emph{shorter} branch and add them to the document
on the \emph{master} branch.

What is more, and this is kind of nice, you can have made changes
to the \emph{master} branch at the same time. That is, the two (or
more) branches can develop in parallel and then join back together
at the point of your chosing. Usually, this will work out just
fine. If, however, each branch made changes to a given line of the
document, then you'll get a \emph{merge-conflict} and you'll have
to go in and make a decision about what the document should look
like at that line.

(This is one (of a few) reasons to use short lines in your LaTeX
document. Since LaTeX doesn't care about line breaks, you can
safely hard-wrap your lines at 72 characters or whatever. This way
a line is usually no more than one or two sentences, which reduces
the number of merge conflicts you run into substantially.)

\subsection{A simple example}

In my simple example, I'll describe my typical workflow. It is
fairly straightfoward, so I think it qualifies. I usually have two
branches going at any one time. The default branch is the
\emph{master} branch. I use a convention followed by many computer
programmers and I try to never write on the \emph{master} branch.
So whenever I start a project I immediately create a \emph{develop}
branch. All my regular writing goes on this branch. When I finish a
draft (generally, when I get to the point that I'm ready to show a
round of people what I've got), I merge the paper at that point
into the master branch. My master branches (ideally) only have
merge commits in them. This is a new workflow for me, so not all my
repositories follow this convention. But I like it. This means that
I can always get the most recent draft by getting the master
branch. This isn't as imporant in our work as it is for programmers
(where the master branch is the stable, released version), but it
does make some sense to me.

Suppose I am writing a paper on unrestricted composition. I have a
draft—maybe a nice 17 page paper—that I think is okay, but I feel
like the most interesting arugment might not be the one I'm making.
Perhaps, I realize, that if I just assume this stuff in section 2
and section 4, then I can add in another section between sections 4
and 5 that shows that my conclusion actually applies to more people
than I realized.

Unless I'm pretty confident that this change is the right one (and
I usually am not), I would probably start a branch here. So
\verb!git checkout -b new_argument! or something. Now I make all
the changes I wanted to make and give the paper a read. If I was
right and this was the right way to go, I can
\verb!git checkout develop!, \verb!git merge new_argument!. If I
realize that this was a terrible mistake, I can instead
\verb!git branch -D new_argument! and that branch—and line of
argument—is deleted.

I like this approach because it gives me a sandbox for my writing.
It might be overkill (like a belt and suspenders), since I can
always check out any version of a project I want (so I could make
the changes on the \emph{develop} branch and then, if they fail,
just \verb!git reset --hard commit-number! to revert back to the
old version). But I think there is something to be said in my
defense. For one thing, I feel more free to explore in a branch. It
is really easy and straightforward to bail on a branch. I don't
have to find the right commit and do a (scary) hard reset. I just
abandon ship. For another thing, suppose that halfway through these
changes I realized that I need to make some changes to the
conclusion. If I've got a branch, I can make that to the master
branch and then merge the new branch in if needed, or I can make
the change to the new branch and then cherry-pick that commit and
merge it into my \emph{develop} branch before I throw the
experimental branch away. Doing that without branching would be
really difficult. (I think I would have to go back and create a
branch after the fact to do this; why not prevent that work and
create the branch up front?)

\subsection{More}

I'd like to say more, but this post is getting long. I'm going to
write a second post that I'll put up soon that walks through
branching in more detail.

\section{Making branches work for you}

I recently wrote a
\href{http://www.charlietanksley.net/philtex/using-a-version-control-system/}{post about using a version control system}
when you write LaTeX documents. In this post I want to talk about a
specific feature of the workflow that I've adopted for my
philosophical writing: branching.

As I mentioned in the previous post, I use
\href{http://git-scm.com/}{git} for my version control needs. One
of the distinctive features of git is that \emph{branches} are
cheap—that is, they are easy to create, easy to integrate into a
workflow, and require very little memory. In this post I'm going to
give a basic explanation of how branches work, explain a toy
example using branches, and then explain how I recently used
branches in a paper.

(I \textbf{think} that cheap branches are a \textbf{distinctive}
feature of git. I could be wrong about this, though. For what it is
worth, if you are using
\href{http://mercurial.selenic.com/}{Mercurial}, there is an
\href{http://stevelosh.com/blog/2009/08/a-guide-to-branching-in-mercurial/}{excellent article explaining how to use bookmarks}
in a way similar to my use of branches.)

\subsection{Branches}

When you use git, you put the files you are tracking in a
repository. You make commits to this repository as you like. A
commit has multiple parts. The two of interest to us now are the
commit message and the change set. Suppose you have a five line
long document and you change the second line from x to y. Then when
you \verb!git commit -am 'meaningful commit message'! to commit
your (tracked) document, git makes a record that says line 2 of the
document was changed to y and attaches your message. After you've
done this a number of times, you end up with a long trail of
changes:

\includegraphics{http://www.charlietanksley.net/images/blog/git-branches-development-line.png}

Call this long line the \emph{development line} of the document.
\emph{Branches} allow you to create multiple parallel development
lines for one document that intersect when and where you see fit.

\subsubsection{Creating branches}

You create a branch in git with the \verb!git branch <branchname>!
command. You check out a branch with
\verb!git checkout <branchname>!. (You can create and checkout a
branch with \verb!git checkout -b <branchname>!.) Branching is
cheap in git in three ways. For one thing, they are easy to create
(we just created one). More importantly, they require very little
overhead (that you need to be aware of). Some version control
systems apparently create a copy of the entire directory when you
create a branch. So in effect, if I have a directory
\verb!papers/current-paper! and I want to create a new branch, I
end up with something like this:

\begin{verbatim}
papers/
- current-paper(main_branch)
- current-paper(new_branch)
\end{verbatim}
I guess that should count as a branch, but it seems wasteful and
confusing. Part of the reason you are using a version control
system is to avoid having lots of versions of your paper saved with
various version-numbers in the name. So it seems odd to do this
exact thing when you create a branch.

When you create a branch in git, you don't really create anything
new (strictly I suppse you create a new pointer to follow certain
change sets, or something like that—but my point is that you don't
create any new \emph{files}). Instead, git just keeps track of the
different sets of changes. When you open up \verb!papers/!, you see
one copy of your files. Suppose that file \verb!paper.tex! is 20
paragraphs long in the main (or \emph{master}) branch. Now suppose
you have a branch, \emph{shorter}, that is only 12 paragraphs long.
If you are on the master branch and run
\verb!git checkout shorter!, the copy of \verb!paper.tex! in that
directory will become (magically!) only 12 paragraphs long. If you
\verb!git checkout master!, then \verb!paper.tex! will change back.
There is just one file. You could have one paper in ten different
states, and you could make that single file be in any of those
states with one command.

This model of branching is very neat and tidy, as it ensures you
only have one copy of each file in your directory (unless you
duplicate it yourself, of course). You can, at any point in time,
create a branch off any of your development lines from any point on
said line. So you could create a branch that starts at the tip of a
given line, or you could go back two weeks ago and create a branch
there. Creating branches is cheap and easy.

Sometimes you'll want to create a branch that branches off the main
development line for one or two changes. I usually do this for
submissions to journals. I take the paper at its best state and
\verb!git checkout -b <journal name>! to create a branch for that
journal. Then I do the things I need to do to make it ready for
submission (like making it blind review). Then compile, print, and
submit that version. I can then \verb!git checkout master! and
switch back to my current version, sans any journal specific
changes. This is nice for two reasons. First, at any point I can
quickly and easily retrieve the exact version I submitted to the
journal (a \verb!git branch! will tell me all my branch names, then
I can easily check it out and compile it). Two, I don't have to
make the changes (like making it blind review), get it ready to
submit, and then undo all the changes for my working version. When
I give a paper to a friend I need to have my name on the pages,
etc., I don't want to keep it blind (or completely double-spaced or
whatever the journal wants). It is easy to switch back to my
current version. (Added benefit: if you don't delete the branches,
you have an easy record of where (and when) you submitted the
paper.)

\subsubsection{Merging branches}

Sometimes you want to create a branch that dead ends—like in the
journal example. But other times you'll want to create branches
that you want to use later. In this case, you'll get to see the
other feature of git branches that makes branching so cheap—easy,
fairly accurate merging. (I don't know how git merging compares to
merging in other systems, so maybe this is all just a given;
nevertheless, it bears mentioning here.) Branching can get
complicated, but in most cases it is pretty straightfoward. You
create a your \emph{shorter} branch, do some work on it, and then
when you are ready, you checkout the \emph{master} branch and run
\verb!git merge shorter!. Git will automatically take the changed
lines from the \emph{shorter} branch and add them to the document
on the \emph{master} branch.

What is more, and this is kind of nice, you can have made changes
to the \emph{master} branch at the same time. That is, the two (or
more) branches can develop in parallel and then join back together
at the point of your chosing. Usually, this will work out just
fine. If, however, each branch made changes to a given line of the
document, then you'll get a \emph{merge-conflict} and you'll have
to go in and make a decision about what the document should look
like at that line.

(This is one (of a few) reasons to use short lines in your LaTeX
document. Since LaTeX doesn't care about line breaks, you can
safely hard-wrap your lines at 72 characters or whatever. This way
a line is usually no more than one or two sentences, which reduces
the number of merge conflicts you run into substantially.)

\subsection{A simple example}

In my simple example, I'll describe my typical workflow. It is
fairly straightfoward, so I think it qualifies. I usually have two
branches going at any one time. The default branch is the
\emph{master} branch. I use a convention followed by many computer
programmers and I try to never write on the \emph{master} branch.
So whenever I start a project I immediately create a \emph{develop}
branch. All my regular writing goes on this branch. When I finish a
draft (generally, when I get to the point that I'm ready to show a
round of people what I've got), I merge the paper at that point
into the master branch. My master branches (ideally) only have
merge commits in them. This is a new workflow for me, so not all my
repositories follow this convention. But I like it. This means that
I can always get the most recent draft by getting the master
branch. This isn't as imporant in our work as it is for programmers
(where the master branch is the stable, released version), but it
does make some sense to me.

Suppose I am writing a paper on unrestricted composition. I have a
draft—maybe a nice 17 page paper—that I think is okay, but I feel
like the most interesting arugment might not be the one I'm making.
Perhaps, I realize, that if I just assume this stuff in section 2
and section 4, then I can add in another section between sections 4
and 5 that shows that my conclusion actually applies to more people
than I realized.

Unless I'm pretty confident that this change is the right one (and
I usually am not), I would probably start a branch here. So
\verb!git checkout -b new_argument! or something. Now I make all
the changes I wanted to make and give the paper a read. If I was
right and this was the right way to go, I can
\verb!git checkout develop!, \verb!git merge new_argument!. If I
realize that this was a terrible mistake, I can instead
\verb!git branch -D new_argument! and that branch—and line of
argument—is deleted.

I like this approach because it gives me a sandbox for my writing.
It might be overkill (like a belt and suspenders), since I can
always check out any version of a project I want (so I could make
the changes on the \emph{develop} branch and then, if they fail,
just \verb!git reset --hard commit-number! to revert back to the
old version). But I think there is something to be said in my
defense. For one thing, I feel more free to explore in a branch. It
is really easy and straightforward to bail on a branch. I don't
have to find the right commit and do a (scary) hard reset. I just
abandon ship. For another thing, suppose that halfway through these
changes I realized that I need to make some changes to the
conclusion. If I've got a branch, I can make that to the master
branch and then merge the new branch in if needed, or I can make
the change to the new branch and then cherry-pick that commit and
merge it into my \emph{develop} branch before I throw the
experimental branch away. Doing that without branching would be
really difficult. (I think I would have to go back and create a
branch after the fact to do this; why not prevent that work and
create the branch up front?)

\subsection{More}

I'd like to say more, but this post is getting long. I'm going to
write a second post that I'll put up soon that walks through
branching in more detail.

\ensuremath{\sim}/Documents/c/git-LaTeX[master] \$ redcloth
git\_branching\_pt2.textile
In
\href{http://www.charlietanksley.net/philtex/git-branching-pt-1-of-2/}{my last post}
I explained a bit how I use branches in my philosophical writing.
In this post I'd like to walk through an example in a bit more
detail, using lots of pictures.

This is a dummy example, but this is exactly how I use branches, so
I hope it is helpful. I start off with a single branch. I've been
writing for a while, making commits to the master branch:

\includegraphics{http://www.charlietanksley.net/images/blog/git-branches/initial-branch.png}

Here is my repository at this point:

\includegraphics{http://www.charlietanksley.net/images/blog/git-branches/terminal-initial-branch.png}

I decide I want to submit this paper to a conference. In order to
avoid having to make it blind, print it, then make it blind again
(and so I remember which version my commentator has!), I opt to
create a branch. \verb!git checkout -b conference_submission! does
this for me. And look, my directory is exactly the same (save my
git branch, which my prompt represents):

\includegraphics{http://www.charlietanksley.net/images/blog/git-branches/term-changed-branches.png}

I go ahead and make a change to the paper to cut it to length and
another to make it blind. I commit both of these. You can see my
two branches diverging here (I'm using gitx here, but you can use
any number of gui frontends for git or just use
\verb!git log --oneline --graph --all --decorate! to see this in
the terminal):

\includegraphics{http://www.charlietanksley.net/images/blog/git-branches/branches-diverge.png}

One thing worth noting here: the \verb!paper.tex! file in my
directory actually shrunk—nothing was duplicated in that
directory:

\includegraphics{http://www.charlietanksley.net/images/blog/git-branches/one-directory.png}

\subsection{Putting branches through their paces}

I could leave things here. Print out the conference version,
\verb!git checkout master!, and keep writing on my paper, going
back to the conference version when or if I need it. But we want to
do something a bit more complicated here.

Here is a snapshot of my git repository:

\includegraphics{http://www.charlietanksley.net/images/blog/git-branches/branches-diverge.png}

In this paper I decided to clean up my abstract on the conference
version before I submitted it. Then on the master branch I changed
one of my terms throughout and made a change to my main argument.
(These happen at virtually the same time here, but that is an
artefact of this example. Usually the changes to the master branch
would've happened after the conference paper was submitted, else I
should've made them to that version and submitted that!).

Now suppose I like the abstract from my conference version and want
to add that to my paper. I could just copy and paste, but that
isn't very adventurous (and would not work for some changes I might
make). Instead, I'll checkout the master branch, find the commit
number for that commit (the SHA, in this case 835502a73), and then
\verb!git cherry-pick 835502a73!. Here is what happens:

\includegraphics{http://www.charlietanksley.net/images/blog/git-branches/post-cherry-pick.png}

You see that though the 'clean up abstract' commit has a different
sha in each branch, it is the exact same set of changes.
Cherry-picking is not the easiest of git operations (you have to be
sure the one commit you are adding in doesn't depend on changes you
don't want to also cherry-pick). But it is a powerful one that
really shows off what branching can do for you.

\subsection{A more run-of-the mill example}

Here is a more run of the mill example of git branches. I decide
that I want to experiment with something, so I create a new branch.
In this case I actually wanted to go back in my history, so I
checked out the master branch, then checked out a specific commit
on that branch, and from there did a
\verb!git checkout -b new_direction! to get a new branch. You'll
see it here, right where my conference version branches off:

\includegraphics{http://www.charlietanksley.net/images/blog/git-branches/back-in-time.png}

Here I've made a change to the paper—the one I wanted to try out
(usually you'd try out more than this, surely):

\includegraphics{http://www.charlietanksley.net/images/blog/git-branches/change.png}

Suppose that change works out for me. I like the new direction and
want to keep it. Now I need to merge it in. So I check out the
master branch and \verb!git merge new_direction!. Unfortunately, in
this case I ran into a merge conflict. When merging two branches
together, git applies the new version to the old version. Any line
that changed in the new version gets changed in the old version. If
a given line, x, has changed in both versions since the branches
diverge, you get a merge conflict. Git doesn't know which version
of line x you want, so you have to tell it yourself. Here is my
merge conflict notice:

\includegraphics{http://www.charlietanksley.net/images/blog/git-branches/merge-conflict.png}

In order to resolve this conflict I have to

\begin{enumerate}
\item
  open \verb!paper.tex!
\item
  look for merge conflicts, which look like
  this:\\\textless{}\textless{}\textless{}\textless{}\textless{}\textless{}
  branch\_name of branch being merged onto\\line x from the
  merge-base branch\\=====\\line x from the branch being merged
  into the
  base\\\textgreater{}\textgreater{}\textgreater{}\textgreater{}\textgreater{}\textgreater{}\textgreater{}
  branch\_name of merging branch
\item
  delete the markers and one of the versions of line x
\item
  add and commit the file to git.
\end{enumerate}
This usually isn't very hard, though it can be kind of scary (well,
it was for me at first).

After the merge, my new\_direction branch changes are part of the
master branch:

\includegraphics{http://www.charlietanksley.net/images/blog/git-branches/post-merge.png}

So now I can \verb!git branch -d new_direction! and get rid of that
(now worthless) branch. If I had decided not to merge the change
in, I could've run \verb!git branch -D new_direction! to get rid of
it (the uppercase D forces git to delete branches that aren't
merged).

Now I've got a repository with two branches: my conference
submission version waiting for acceptance and my master branch,
which has moved on.

\includegraphics{http://www.charlietanksley.net/images/blog/git-branches/final-shot.png}

\subsection{Conclusion}

I hope this was helpful. Let me know if you have questions about
branching and I'll do my best to answer them. The best thing you
can do is just experiment and play around. Remember, it is really
hard to lose stuff in git. Just find the place you want to go in
your history (a tool like gitx is invaluable for this unless you
are a commandline wizard) and \verb!git checkout that-sha!. Then
create a branch and you are off to the races.



\end{document}
